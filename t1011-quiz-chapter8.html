<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Chapitre 8 - Supports Magn√©tiques P1 | T1011</title>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #09090b; --bg-secondary: #18181b; --bg-tertiary: #27272a;
            --bg-card: linear-gradient(145deg, rgba(39, 39, 42, 0.5), rgba(24, 24, 27, 0.8));
            --border: rgba(63, 63, 70, 0.5); --border-hover: rgba(113, 113, 122, 0.5);
            --text-primary: #fafafa; --text-secondary: #a1a1aa; --text-muted: #71717a;
            --accent-1: #3b82f6; --accent-2: #8b5cf6; --success: #22c55e; --danger: #ef4444;
            --gradient-primary: linear-gradient(135deg, #3b82f6, #8b5cf6);
        }
        body { font-family: 'Sora', sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; -webkit-font-smoothing: antialiased; }
        .bg-gradient { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59, 130, 246, 0.15), transparent), radial-gradient(ellipse 60% 50% at 100% 50%, rgba(139, 92, 246, 0.1), transparent); pointer-events: none; z-index: 0; }
        .noise { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); opacity: 0.03; pointer-events: none; z-index: 1; }
        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; position: relative; z-index: 2; }
        .header { background: var(--bg-card); backdrop-filter: blur(20px); border: 1px solid var(--border); border-radius: 20px; padding: 24px 32px; margin-bottom: 32px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px; }
        .header-left { display: flex; align-items: center; gap: 16px; }
        .back-btn { display: flex; align-items: center; justify-content: center; width: 44px; height: 44px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; color: var(--text-secondary); text-decoration: none; font-size: 1.3rem; transition: all 0.3s ease; }
        .back-btn:hover { background: var(--bg-tertiary); border-color: var(--border-hover); color: var(--text-primary); transform: translateX(-3px); }
        .header-title h1 { font-size: 1.5rem; font-weight: 700; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-title p { font-size: 0.85rem; color: var(--text-muted); margin-top: 4px; }
        .header-score { text-align: center; padding: 12px 24px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; }
        .score-value { font-size: 1.8rem; font-weight: 700; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .score-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .progress-container { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 16px; padding: 20px 24px; margin-bottom: 32px; }
        .progress-header { display: flex; justify-content: space-between; margin-bottom: 12px; }
        .progress-text { font-size: 0.85rem; color: var(--text-secondary); font-weight: 600; }
        .progress-bar-bg { height: 10px; background: var(--bg-tertiary); border-radius: 100px; overflow: hidden; }
        .progress-bar { height: 100%; background: var(--gradient-primary); border-radius: 100px; transition: width 0.5s ease; width: 0%; }
        .question-card { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 20px; padding: 32px; margin-bottom: 24px; }
        .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .question-number { font-size: 0.8rem; font-weight: 600; color: var(--accent-1); text-transform: uppercase; letter-spacing: 1px; }
        .question-type { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 100px; font-size: 0.75rem; font-weight: 500; color: var(--text-muted); }
        .question-text { font-size: 1.1rem; font-weight: 500; color: var(--text-primary); line-height: 1.6; margin-bottom: 24px; }
        .options { display: flex; flex-direction: column; gap: 12px; }
        .option { padding: 16px 20px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.3s ease; font-size: 0.95rem; color: var(--text-secondary); }
        .option:hover { border-color: var(--border-hover); background: var(--bg-tertiary); color: var(--text-primary); }
        .option.selected { border-color: var(--accent-1); background: rgba(59, 130, 246, 0.1); color: var(--text-primary); }
        .option.correct { border-color: var(--success); background: rgba(34, 197, 94, 0.1); color: var(--success); }
        .option.incorrect { border-color: var(--danger); background: rgba(239, 68, 68, 0.1); color: var(--danger); }
        .option.disabled { cursor: not-allowed; opacity: 0.6; }
        .fill-blank-input { padding: 12px 16px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'Sora', sans-serif; font-size: 0.95rem; width: 100%; max-width: 400px; transition: all 0.3s ease; }
        .fill-blank-input:focus { outline: none; border-color: var(--accent-1); background: var(--bg-tertiary); }
        .fill-blank-input.correct { border-color: var(--success); background: rgba(34, 197, 94, 0.1); }
        .fill-blank-input.incorrect { border-color: var(--danger); background: rgba(239, 68, 68, 0.1); }
        .explanation { margin-top: 20px; padding: 16px 20px; background: rgba(59, 130, 246, 0.05); border-left: 3px solid var(--accent-1); border-radius: 8px; display: none; }
        .explanation.show { display: block; }
        .explanation-title { font-size: 0.85rem; font-weight: 600; color: var(--accent-1); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .explanation-text { font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; }
        .buttons-container { display: flex; gap: 12px; margin-top: 32px; }
        .btn { flex: 1; padding: 14px 24px; border: none; border-radius: 12px; font-family: 'Sora', sans-serif; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: var(--gradient-primary); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px -8px rgba(59, 130, 246, 0.5); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-secondary { background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-secondary); }
        .btn-secondary:hover { background: var(--bg-tertiary); border-color: var(--border-hover); color: var(--text-primary); }
        .results-container { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 20px; padding: 40px; text-align: center; display: none; }
        .results-container.show { display: block; }
        .results-icon { font-size: 4rem; margin-bottom: 20px; }
        .results-title { font-size: 2rem; font-weight: 700; margin-bottom: 12px; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .results-score { font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 32px; }
        .results-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 16px; margin-bottom: 32px; }
        .result-stat { padding: 16px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; }
        .result-stat-value { font-size: 1.8rem; font-weight: 700; margin-bottom: 4px; }
        .result-stat-value.success { color: var(--success); }
        .result-stat-value.danger { color: var(--danger); }
        .result-stat-value.primary { background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .result-stat-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .hidden { display: none !important; }
        @media (max-width: 768px) {
            .header { flex-direction: column; align-items: flex-start; }
            .header-score { width: 100%; }
            .buttons-container { flex-direction: column; }
            .results-stats { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    <div class="noise"></div>

    <div class="container">
        <div class="header">
            <div class="header-left">
                <a href="index.html" class="back-btn">‚Üê</a>
                <div class="header-title">
                    <h1>Chapitre 8 - Supports Magn√©tiques P1</h1>
                    <p>Disques durs, t√™tes de lecture</p>
                </div>
            </div>
            <div class="header-score">
                <div class="score-value" id="current-score">0%</div>
                <div class="score-label">Score</div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-header">
                <span class="progress-text">Question <span id="current-question">1</span>/<span id="total-questions">30</span></span>
                <span class="progress-text" id="progress-percentage">0%</span>
            </div>
            <div class="progress-bar-bg">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <div id="quiz-container"></div>

        <div class="results-container" id="results-container">
            <div class="results-icon" id="results-icon">üéâ</div>
            <h2 class="results-title" id="results-title">Quiz termin√© !</h2>
            <p class="results-score" id="results-message">Excellent travail !</p>
            
            <div class="results-stats">
                <div class="result-stat">
                    <div class="result-stat-value primary" id="final-score">0%</div>
                    <div class="result-stat-label">Score Final</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value success" id="correct-answers">0</div>
                    <div class="result-stat-label">Correctes</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value danger" id="incorrect-answers">0</div>
                    <div class="result-stat-label">Incorrectes</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value primary" id="xp-earned">0</div>
                    <div class="result-stat-label">XP Gagn√©</div>
                </div>
            </div>

            <div class="buttons-container">
                <button class="btn btn-secondary" onclick="window.location.href='index.html'">Retour</button>
                <button class="btn btn-primary" onclick="restartQuiz()">Recommencer</button>
            </div>
        </div>
    </div>

    <script>
        const questionsBank = [
            // QCM - Supports Magn√©tiques P1
            {
                type: 'qcm',
                question: "Quel fut le premier disque dur commercialis√© par IBM en 1956 ?",
                options: ["ENIAC", "RAMAC 305", "EDVAC", "Mark 1"],
                correct: 1,
                explanation: "Le RAMAC 305 (Random Access Method of Accounting And Control) fut le premier disque dur commercialis√© en 1956 avec 5 Mo de capacit√©."
            },
            {
                type: 'qcm',
                question: "Quelle √©tait la capacit√© du RAMAC 305 ?",
                options: ["500 Ko", "5 Mo", "50 Mo", "500 Mo"],
                correct: 1,
                explanation: "Le RAMAC 305 (1956) avait une capacit√© de 5 m√©gaoctets, ce qui √©tait r√©volutionnaire pour l'√©poque."
            },
            {
                type: 'qcm',
                question: "Quelles substances ferromagn√©tiques sont principalement utilis√©es dans les supports magn√©tiques ?",
                options: [
                    "Fer, Nickel, Cobalt",
                    "Cuivre, Zinc, Aluminium",
                    "Or, Argent, Platine",
                    "Carbone, Silicium, Phosphore"
                ],
                correct: 0,
                explanation: "Les substances ferromagn√©tiques utilis√©es sont principalement le Fer, le Nickel et le Cobalt pour leur propri√©t√© d'aimantation r√©siduelle."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce que l'aimantation r√©manente (ou r√©siduelle) ?",
                options: [
                    "L'aimantation temporaire",
                    "L'aimantation qui reste apr√®s retrait du champ magn√©tique",
                    "L'aimantation initiale",
                    "L'aimantation maximale"
                ],
                correct: 1,
                explanation: "L'aimantation r√©manente (M+) est l'aimantation qui persiste dans le mat√©riau apr√®s le retrait du champ magn√©tique externe."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce que le champ coercitif (Hc) ?",
                options: [
                    "Le champ magn√©tique maximal",
                    "Le champ n√©cessaire pour ramener l'aimantation √† z√©ro",
                    "Le champ de lecture",
                    "Le champ d'√©criture"
                ],
                correct: 1,
                explanation: "Le champ coercitif (Hc) est l'intensit√© du champ magn√©tique inverse n√©cessaire pour ramener l'aimantation √† z√©ro."
            },
            {
                type: 'qcm',
                question: "Quelle est la taille actuelle approximative des particules magn√©tiques sur un disque dur ?",
                options: ["25 nm", "250 nm sur 30 nm", "2500 nm", "25 ¬µm"],
                correct: 1,
                explanation: "Les particules magn√©tiques actuelles mesurent environ 250 nanom√®tres sur 30 nanom√®tres de hauteur."
            },
            {
                type: 'qcm',
                question: "Quel ph√©nom√®ne physique limite la miniaturisation des particules magn√©tiques ?",
                options: [
                    "La surchauffe",
                    "Le superparamagn√©tisme",
                    "L'oxydation",
                    "La conductivit√©"
                ],
                correct: 1,
                explanation: "Le superparamagn√©tisme : quand deux particules aux polarit√©s contraires sont trop proches, il peut y avoir des interf√©rences et inversions spontan√©es de polarit√©."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce que la technologie 'Pixie Dust' (AFC - Anti-Ferromagnetically Coupled) ?",
                options: [
                    "Un nouveau type de t√™te de lecture",
                    "Un rev√™tement de 3 atomes de ruth√©nium entre 2 couches magn√©tiques",
                    "Un type de disque optique",
                    "Un algorithme de compression"
                ],
                correct: 1,
                explanation: "Pixie Dust (2001) : rev√™tement de 3 atomes de ruth√©nium entre 2 couches magn√©tiques, permettant d'atteindre 25,7 Gbits/pouce¬≤ et jusqu'√† 400 Gbits/pouce¬≤."
            },
            {
                type: 'qcm',
                question: "Quel type de t√™te a √©t√© introduit par IBM en 1991 ?",
                options: [
                    "T√™te inductive",
                    "T√™te magn√©to-r√©sistance (MR)",
                    "T√™te laser",
                    "T√™te optique"
                ],
                correct: 1,
                explanation: "La t√™te magn√©to-r√©sistance (MR) d'IBM (1991) observe les variations de r√©sistance caus√©es par le champ magn√©tique, donnant un signal plus fort et clair."
            },
            {
                type: 'qcm',
                question: "Pourquoi la t√™te MR (magn√©to-r√©sistance) n√©cessite-t-elle DEUX t√™tes ?",
                options: [
                    "Pour aller plus vite",
                    "Elle ne fonctionne qu'en lecture, il faut une t√™te s√©par√©e pour l'√©criture",
                    "Pour la redondance",
                    "Pour le refroidissement"
                ],
                correct: 1,
                explanation: "La t√™te MR ne fonctionne qu'en LECTURE. Il faut donc une seconde t√™te pour l'√âCRITURE."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce que la t√™te GMR introduite par IBM en 1997 ?",
                options: [
                    "Giant Magnetic Recorder",
                    "Giant Magneto Resistive (r√©sistance g√©ante)",
                    "Global Memory Reader",
                    "Graphic Memory Recorder"
                ],
                correct: 1,
                explanation: "GMR (Giant Magneto Resistive) : effet d√©couvert en 1988, changements de r√©sistance consid√©rables dans des couches altern√©es de m√©taux. Plus petit que la MR classique."
            },

            // QRM
            {
                type: 'qrm',
                question: "Quels sont les modes d'enregistrement magn√©tique ? (Plusieurs r√©ponses)",
                options: [
                    "Enregistrement longitudinal",
                    "Enregistrement perpendiculaire",
                    "Enregistrement diagonal",
                    "Enregistrement circulaire",
                    "Enregistrement spiral√©"
                ],
                correct: [0, 1],
                explanation: "Les deux principaux modes d'enregistrement sont : longitudinal (parall√®le √† la surface) et perpendiculaire (vertical, perpendiculaire √† la surface)."
            },
            {
                type: 'qrm',
                question: "Quelles sont les caract√©ristiques du cycle d'hyst√©r√©sis ? (Plusieurs r√©ponses)",
                options: [
                    "Caract√©rise les milieux magn√©tisables",
                    "D√©termine la taille des aiguilles",
                    "Indique l'aimantation r√©manente",
                    "Indique le champ coercitif",
                    "Mesure la temp√©rature"
                ],
                correct: [0, 1, 2, 3],
                explanation: "Le cycle d'hyst√©r√©sis caract√©rise le mat√©riau magn√©tisable : taille des aiguilles, aimantation r√©manente, champ coercitif. Pas de mesure de temp√©rature."
            },
            {
                type: 'qrm',
                question: "Quelles technologies de t√™tes ont √©t√© d√©velopp√©es ? (Dans l'ordre chronologique)",
                options: [
                    "T√™te inductive en Ferrite (1996)",
                    "T√™te magn√©to-r√©sistance MR (1991)",
                    "T√™te magn√©to-r√©sistance g√©ante GMR (1997)",
                    "T√™te laser HAMR",
                    "T√™te optique"
                ],
                correct: [1, 0, 2],
                explanation: "Ordre chronologique : MR (1991) ‚Üí Inductive Ferrite (1996) ‚Üí GMR (1997). HAMR est plus r√©cent mais pas dans cette liste historique pr√©cise."
            },
            {
                type: 'qrm',
                question: "Quels sont les probl√®mes de la miniaturisation des particules magn√©tiques ? (Plusieurs r√©ponses)",
                options: [
                    "Superparamagn√©tisme",
                    "Interf√©rences entre particules proches",
                    "Inversions spontan√©es de polarit√©",
                    "Surchauffe excessive",
                    "Trop rapide"
                ],
                correct: [0, 1, 2],
                explanation: "Miniaturisation : cause le superparamagn√©tisme, des interf√©rences entre particules trop proches, et des inversions spontan√©es. Pas de probl√®me de surchauffe ou vitesse."
            },

            // Fill
            {
                type: 'fill',
                question: "Le premier disque dur commercialis√© par IBM en 1956 s'appelait le _______ 305.",
                answer: ["RAMAC", "Ramac", "ramac"],
                explanation: "RAMAC 305 = Random Access Method of Accounting And Control (1956, 5 Mo)."
            },
            {
                type: 'fill',
                question: "Les trois principales substances ferromagn√©tiques sont le Fer, le Nickel et le _______.",
                answer: ["Cobalt", "cobalt"],
                explanation: "Fer, Nickel et Cobalt sont les trois principales substances ferromagn√©tiques utilis√©es."
            },
            {
                type: 'fill',
                question: "L'aimantation _______ est celle qui reste apr√®s retrait du champ magn√©tique.",
                answer: ["r√©manente", "remanente", "r√©siduelle", "residuelle"],
                explanation: "L'aimantation r√©manente (ou r√©siduelle) persiste apr√®s le retrait du champ magn√©tique externe."
            },
            {
                type: 'fill',
                question: "Le ph√©nom√®ne qui limite la miniaturisation des particules magn√©tiques s'appelle le _______.",
                answer: ["superparamagn√©tisme", "Superparamagn√©tisme"],
                explanation: "Le superparamagn√©tisme cause des inversions spontan√©es de polarit√© quand les particules sont trop petites et proches."
            },
            {
                type: 'fill',
                question: "La technologie Pixie Dust utilise un rev√™tement de 3 atomes de _______.",
                answer: ["ruth√©nium", "Ruth√©nium"],
                explanation: "Pixie Dust (AFC - 2001) : 3 atomes de ruth√©nium entre 2 couches magn√©tiques."
            },
            {
                type: 'fill',
                question: "La t√™te _______ (1991) observe les variations de r√©sistance mais ne fonctionne qu'en lecture.",
                answer: ["MR", "magn√©to-r√©sistance", "magneto-resistance"],
                explanation: "La t√™te MR (Magn√©to-R√©sistance, 1991) fonctionne uniquement en lecture, n√©cessitant une t√™te s√©par√©e pour l'√©criture."
            },
            {
                type: 'fill',
                question: "GMR signifie Giant Magneto _______.",
                answer: ["Resistive", "resistive", "R√©sistive", "resistive"],
                explanation: "GMR = Giant Magneto Resistive (r√©sistance g√©ante), technologie IBM de 1997."
            },
            {
                type: 'fill',
                question: "L'enregistrement _______ oriente l'aimantation parall√®lement √† la surface du disque.",
                answer: ["longitudinal", "Longitudinal"],
                explanation: "L'enregistrement longitudinal oriente l'aimantation horizontalement (parall√®le √† la surface)."
            },
            {
                type: 'fill',
                question: "L'enregistrement _______ oriente l'aimantation verticalement par rapport √† la surface.",
                answer: ["perpendiculaire", "Perpendiculaire"],
                explanation: "L'enregistrement perpendiculaire (PRM) oriente l'aimantation verticalement, permettant de meilleures densit√©s."
            },
            // QCM
            {
                type: 'qcm',
                question: "Quel composant de l'Unit√© de Commande contient l'adresse de la prochaine instruction √† ex√©cuter ?",
                options: ["Registre d'instruction", "D√©codeur", "Compteur ordinal", "S√©quenceur"],
                correct: 2,
                explanation: "Le compteur ordinal (ou Program Counter) contient l'adresse de la prochaine instruction √† ex√©cuter."
            },
            {
                type: 'qcm',
                question: "Que signifie CPU ?",
                options: ["Computer Processing Unit", "Central Processing Unit", "Central Program Unit", "Computer Program Unit"],
                correct: 1,
                explanation: "CPU signifie Central Processing Unit (Unit√© Centrale de Traitement en fran√ßais)."
            },
            {
                type: 'qcm',
                question: "Quel composant interpr√®te l'instruction contenue dans le registre d'instruction ?",
                options: ["Le s√©quenceur", "Le d√©codeur", "Le compteur ordinal", "L'UAL"],
                correct: 1,
                explanation: "Le d√©codeur interpr√®te l'instruction pour d√©terminer quelle op√©ration effectuer et comment aller chercher les op√©randes."
            },
            {
                type: 'qcm',
                question: "Quels sont les deux champs qui composent une instruction ?",
                options: [
                    "Code instruction et code donn√©es",
                    "Code op√©ration et code op√©rande",
                    "Code source et code destination",
                    "Code registre et code m√©moire"
                ],
                correct: 1,
                explanation: "Une instruction est compos√©e de deux champs : le code op√©ration (d√©finit l'action) et le code op√©rande (d√©finit les param√®tres/adresses)."
            },
            {
                type: 'qcm',
                question: "Quel composant g√©n√®re les microcommandes pour piloter les autres entit√©s du ¬µP ?",
                options: ["Le d√©codeur", "Le s√©quenceur", "Le registre d'√©tat", "Le compteur ordinal"],
                correct: 1,
                explanation: "Le s√©quenceur g√©n√®re une s√©quence de microcommandes rythm√©es par l'horloge pour piloter les composants du ¬µP."
            },
            {
                type: 'qcm',
                question: "Que fait l'UAL (ALU) √† la fin d'une op√©ration en cas de d√©bordement ?",
                options: [
                    "Elle arr√™te le processeur",
                    "Elle met le bit OF (OverFlow) du registre d'√©tat √† 1",
                    "Elle efface le r√©sultat",
                    "Elle d√©clenche une interruption"
                ],
                correct: 1,
                explanation: "En cas de d√©bordement (r√©sultat trop grand), l'UAL met le bit OF (OverFlow) du registre d'√©tat √† 1 pour signaler le probl√®me."
            },
            {
                type: 'qcm',
                question: "Comment s'appelle le bus qui v√©hicule les instructions ET les donn√©es entre les composants ?",
                options: ["Bus d'adresses", "Bus de donn√©es", "Bus de commandes", "Bus de contr√¥le"],
                correct: 1,
                explanation: "Le bus de donn√©es (Data Bus) sert au transfert des informations, que ce soient des instructions ou des donn√©es."
            },
            {
                type: 'qcm',
                question: "Quelle est la particularit√© du bus de donn√©es ?",
                options: [
                    "Il est unidirectionnel",
                    "Il est bidirectionnel",
                    "Il ne transporte que des adresses",
                    "Il fonctionne √† sens unique"
                ],
                correct: 1,
                explanation: "Le bus de donn√©es est bidirectionnel car les informations peuvent circuler dans les deux sens : UC ‚Üí m√©moire et m√©moire ‚Üí UC."
            },
            {
                type: 'qcm',
                question: "Avec un bus d'adresse de 16 bits, combien de m√©moire peut-on adresser directement ?",
                options: ["16 Ko", "64 Ko", "256 Ko", "1 Mo"],
                correct: 1,
                explanation: "Avec 16 bits on peut obtenir 2^16 = 65536 combinaisons = 64 Ko de m√©moire adressable."
            },
            {
                type: 'qcm',
                question: "Avec un bus d'adresse de 32 bits, quelle est la taille maximale de m√©moire adressable ?",
                options: ["1 Go", "2 Go", "4 Go", "8 Go"],
                correct: 2,
                explanation: "Un bus d'adresse de 32 bits permet d'adresser 2^32 octets = 4 Go de m√©moire physique."
            },
            {
                type: 'qcm',
                question: "Quel composant du CPU est compos√© de circuits logiques comme des additionneurs et comparateurs ?",
                options: ["L'UC", "L'UAL", "Le d√©codeur", "Le s√©quenceur"],
                correct: 1,
                explanation: "L'UAL (Unit√© Arithm√©tique et Logique) est compos√©e de circuits logiques tels que additionneurs, comparateurs, etc."
            },
            {
                type: 'qcm',
                question: "D'o√π l'UAL re√ßoit-elle ses op√©randes (donn√©es √† manipuler) ?",
                options: [
                    "Du s√©quenceur",
                    "Du bus des donn√©es",
                    "Du registre d'instruction",
                    "Du compteur ordinal"
                ],
                correct: 1,
                explanation: "L'UAL re√ßoit ses op√©randes du bus des donn√©es. Ces donn√©es peuvent provenir de la m√©moire ou de registres."
            },
            {
                type: 'qcm',
                question: "Quel registre m√©morise les √©tats 'particuliers' g√©n√©r√©s par une op√©ration (retenue, d√©bordement, etc.) ?",
                options: ["Registre d'instruction", "Compteur ordinal", "Registre d'√©tat", "S√©quenceur"],
                correct: 2,
                explanation: "Le registre d'√©tat (PSW - Program Status Word) m√©morise les √©tats particuliers via des flags (drapeaux)."
            },
            {
                type: 'qcm',
                question: "Que signifie le flag ZF dans le registre d'√©tat ?",
                options: [
                    "Zero Flag - le r√©sultat est nul",
                    "Zone Flag - zone m√©moire",
                    "Z√©ro Force - forcer √† z√©ro",
                    "Zap Flag - effacer"
                ],
                correct: 0,
                explanation: "ZF (Zero Flag) indique que le r√©sultat de la derni√®re op√©ration est nul (√©gal √† z√©ro)."
            },
            {
                type: 'qcm',
                question: "Dans quel sens circulent les adresses sur le bus d'adresses ?",
                options: [
                    "Bidirectionnel",
                    "Unidirectionnel : UC ‚Üí m√©moire",
                    "Unidirectionnel : m√©moire ‚Üí UC",
                    "Multi-directionnel"
                ],
                correct: 1,
                explanation: "Le bus d'adresses est unidirectionnel : les adresses circulent uniquement dans le sens UC ‚Üí m√©moire."
            },

            // QRM
            {
                type: 'qrm',
                question: "Quels sont les composants de l'Unit√© de Commande (UC) ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Registre d'instruction",
                    "UAL",
                    "D√©codeur",
                    "S√©quenceur",
                    "Registre d'√©tat",
                    "Compteur ordinal"
                ],
                correct: [0, 2, 3, 4, 5],
                explanation: "L'UC comprend : le registre d'instruction, le d√©codeur, le s√©quenceur, le registre d'√©tat et le compteur ordinal. L'UAL fait partie de l'unit√© de calcul, pas de l'UC."
            },
            {
                type: 'qrm',
                question: "Quelles sont les fonctions du CPU ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Acqu√©rir et d√©coder les instructions",
                    "Faire ex√©cuter les op√©rations arithm√©tiques par l'UAL",
                    "G√©rer les adresses du programme via le compteur ordinal",
                    "M√©moriser l'√©tat interne via le registre d'√©tat",
                    "Afficher les r√©sultats √† l'√©cran"
                ],
                correct: [0, 1, 2, 3],
                explanation: "Le CPU acquiert/d√©code les instructions, fait ex√©cuter l'UAL, g√®re les adresses, m√©morise l'√©tat interne et fournit les signaux de commande. L'affichage n'est pas sa fonction."
            },
            {
                type: 'qrm',
                question: "Quels sont les 3 bus fondamentaux du processeur ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Bus de donn√©es",
                    "Bus d'adresses",
                    "Bus de commandes",
                    "Bus de contr√¥le",
                    "Bus m√©moire",
                    "Bus graphique"
                ],
                correct: [0, 1, 2],
                explanation: "Les 3 bus fondamentaux sont : le bus de donn√©es, le bus d'adresses et le bus de commandes (ou contr√¥le)."
            },
            {
                type: 'qrm',
                question: "Quand le compteur ordinal est-il modifi√© ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Au lancement du programme (chargement 1√®re instruction)",
                    "Lors de sauts (boucles, alternatives)",
                    "Il est incr√©ment√© (+1) pour passer √† l'instruction suivante",
                    "Lors d'une division par z√©ro",
                    "Quand la m√©moire est pleine"
                ],
                correct: [0, 1, 2],
                explanation: "Le compteur ordinal est modifi√© : au lancement du programme, lors de sauts, et il est incr√©ment√© (+1) pour les instructions s√©quentielles."
            },
            {
                type: 'qrm',
                question: "Quels flags (indicateurs) peut-on trouver dans le registre d'√©tat ? (Plusieurs r√©ponses possibles)",
                options: [
                    "CF - Carry Flag (retenue)",
                    "ZF - Zero Flag (r√©sultat nul)",
                    "OF - OverFlow (d√©bordement)",
                    "MF - Memory Flag (m√©moire)",
                    "SF - Sign Flag (signe)"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Les flags incluent : CF (Carry), ZF (Zero), OF (OverFlow), SF (Sign). MF n'existe pas dans les registres d'√©tat standards."
            },
            {
                type: 'qrm',
                question: "Que permet le bus de commandes ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Faire circuler les microcommandes du s√©quenceur",
                    "Indiquer ce que le processeur veut faire",
                    "G√©rer les lectures et √©critures",
                    "Transporter des donn√©es",
                    "G√©rer les interruptions"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Le bus de commandes permet la circulation des microcommandes, indique les intentions du processeur (lecture/√©criture), et g√®re les interruptions. Il ne transporte PAS de donn√©es."
            },

            // Fill in the blank
            {
                type: 'fill',
                question: "Le _______ _______ contient l'instruction √† ex√©cuter.",
                answer: ["registre d'instruction", "registre instruction", "RI"],
                explanation: "Le registre d'instruction (RI) contient l'instruction √† ex√©cuter, dont l'adresse se trouve dans le compteur ordinal."
            },
            {
                type: 'fill',
                question: "CPU signifie Central _______ Unit.",
                answer: ["Processing", "processing"],
                explanation: "CPU signifie Central Processing Unit (Unit√© Centrale de Traitement)."
            },
            {
                type: 'fill',
                question: "Le _______ interpr√®te l'instruction pour d√©terminer quelle op√©ration effectuer.",
                answer: ["d√©codeur", "D√©codeur", "decodeur"],
                explanation: "Le d√©codeur interpr√®te le code op√©ration pour savoir quelle op√©ration effectuer et comment chercher les op√©randes."
            },
            {
                type: 'fill',
                question: "Le _______ g√©n√®re les microcommandes rythm√©es par l'horloge.",
                answer: ["s√©quenceur", "S√©quenceur", "sequenceur"],
                explanation: "Le s√©quenceur g√©n√®re une s√©quence de microcommandes chronologiques pour piloter les composants du ¬µP."
            },
            {
                type: 'fill',
                question: "L'Unit√© de Commande et l'Unit√© Arithm√©tique & Logique constituent l'Unit√© _______.",
                answer: ["Centrale", "centrale", "CPU"],
                explanation: "L'UC (Unit√© de Commande) et l'UAL forment ensemble l'Unit√© Centrale (CPU - Central Processing Unit)."
            },
            {
                type: 'fill',
                question: "Le bus de donn√©es est _______ car les informations circulent dans les deux sens.",
                answer: ["bidirectionnel", "Bidirectionnel"],
                explanation: "Le bus de donn√©es est bidirectionnel : les donn√©es peuvent aller de l'UC vers la m√©moire et inversement."
            },
            {
                type: 'fill',
                question: "Le bus d'adresses est _______ : les adresses ne circulent que de l'UC vers la m√©moire.",
                answer: ["unidirectionnel", "Unidirectionnel"],
                explanation: "Le bus d'adresses est unidirectionnel car seule l'UC envoie des adresses vers la m√©moire, jamais l'inverse."
            },
            {
                type: 'fill',
                question: "Le registre d'√©tat est aussi appel√© _______ (Program Status Word).",
                answer: ["PSW", "psw"],
                explanation: "Le registre d'√©tat porte aussi le nom de PSW (Program Status Word) qui m√©morise l'√©tat du processeur via des flags."
            },
            {
                type: 'fill',
                question: "Le compteur ordinal est aussi appel√© _______ (Program Counter).",
                answer: ["PC", "pc"],
                explanation: "Le compteur ordinal est aussi appel√© PC (Program Counter) ou IP (Instruction Pointer)."
            }
        ];

        let currentQuestionIndex = 0;
        let score = 0;
        let answeredQuestions = 0;
        let shuffledQuestions = [];
        let userAnswers = [];

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function initQuiz() {
            shuffledQuestions = shuffleArray(questionsBank);
            currentQuestionIndex = 0;
            score = 0;
            answeredQuestions = 0;
            userAnswers = new Array(shuffledQuestions.length).fill(null);
            document.getElementById('total-questions').textContent = shuffledQuestions.length;
            updateProgress();
            displayQuestion();
        }

        function displayQuestion() {
            const question = shuffledQuestions[currentQuestionIndex];
            const container = document.getElementById('quiz-container');
            let optionsHTML = '';
            
            if (question.type === 'qcm' || question.type === 'qrm') {
                optionsHTML = '<div class="options">';
                question.options.forEach((option, index) => {
                    const isSelected = userAnswers[currentQuestionIndex]?.includes(index);
                    optionsHTML += `<div class="option ${isSelected ? 'selected' : ''}" onclick="selectOption(${index})">${option}</div>`;
                });
                optionsHTML += '</div>';
            } else if (question.type === 'fill') {
                const userAnswer = userAnswers[currentQuestionIndex] || '';
                optionsHTML = `<input type="text" class="fill-blank-input" id="fill-input" placeholder="Entrez votre r√©ponse..." value="${userAnswer}" onkeyup="handleFillInput(event)">`;
            }
            
            const typeLabel = question.type === 'qcm' ? 'QCM' : question.type === 'qrm' ? 'QRM' : 'Texte √† trou';
            
            container.innerHTML = `
                <div class="question-card">
                    <div class="question-header">
                        <div class="question-number">Question ${currentQuestionIndex + 1}</div>
                        <div class="question-type">${typeLabel}</div>
                    </div>
                    <div class="question-text">${question.question}</div>
                    ${optionsHTML}
                    <div class="explanation" id="explanation">
                        <div class="explanation-title">üí° Explication</div>
                        <div class="explanation-text">${question.explanation}</div>
                    </div>
                </div>
                <div class="buttons-container">
                    ${currentQuestionIndex > 0 ? '<button class="btn btn-secondary" onclick="previousQuestion()">Pr√©c√©dent</button>' : ''}
                    ${currentQuestionIndex < shuffledQuestions.length - 1 
                        ? '<button class="btn btn-primary" id="next-btn" onclick="nextQuestion()" disabled>Valider & Suivant</button>'
                        : '<button class="btn btn-primary" id="next-btn" onclick="finishQuiz()" disabled>Valider & Terminer</button>'}
                </div>
            `;

            if (userAnswers[currentQuestionIndex] !== null) {
                document.getElementById('next-btn').disabled = false;
            }
        }

        function selectOption(index) {
            const question = shuffledQuestions[currentQuestionIndex];
            if (question.type === 'qcm') {
                userAnswers[currentQuestionIndex] = [index];
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.toggle('selected', i === index);
                });
            } else if (question.type === 'qrm') {
                if (!userAnswers[currentQuestionIndex]) {
                    userAnswers[currentQuestionIndex] = [];
                }
                const answers = userAnswers[currentQuestionIndex];
                const idx = answers.indexOf(index);
                if (idx > -1) {
                    answers.splice(idx, 1);
                } else {
                    answers.push(index);
                }
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.toggle('selected', answers.includes(i));
                });
            }
            document.getElementById('next-btn').disabled = false;
        }

        function handleFillInput(event) {
            const value = event.target.value.trim();
            userAnswers[currentQuestionIndex] = value;
            document.getElementById('next-btn').disabled = value === '';
        }

        function validateAnswer() {
            const question = shuffledQuestions[currentQuestionIndex];
            const userAnswer = userAnswers[currentQuestionIndex];
            let isCorrect = false;

            if (question.type === 'qcm') {
                isCorrect = userAnswer[0] === question.correct;
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.add('disabled');
                    if (i === question.correct) {
                        opt.classList.add('correct');
                    } else if (userAnswer.includes(i)) {
                        opt.classList.add('incorrect');
                    }
                });
            } else if (question.type === 'qrm') {
                const sortedUser = [...userAnswer].sort();
                const sortedCorrect = [...question.correct].sort();
                isCorrect = JSON.stringify(sortedUser) === JSON.stringify(sortedCorrect);
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.add('disabled');
                    if (question.correct.includes(i)) {
                        opt.classList.add('correct');
                    } else if (userAnswer.includes(i)) {
                        opt.classList.add('incorrect');
                    }
                });
            } else if (question.type === 'fill') {
                const normalizedUser = userAnswer.toLowerCase().trim();
                isCorrect = question.answer.some(ans => ans.toLowerCase() === normalizedUser);
                const input = document.getElementById('fill-input');
                input.disabled = true;
                if (isCorrect) {
                    input.classList.add('correct');
                } else {
                    input.classList.add('incorrect');
                }
            }

            if (isCorrect) score++;
            answeredQuestions++;
            document.getElementById('explanation').classList.add('show');
            updateProgress();
        }

        function nextQuestion() {
            if (userAnswers[currentQuestionIndex] === null) return;
            validateAnswer();
            currentQuestionIndex++;
            displayQuestion();
            updateProgress();
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
                updateProgress();
            }
        }

        function finishQuiz() {
            if (userAnswers[currentQuestionIndex] === null) return;
            validateAnswer();
            showResults();
        }

        function showResults() {
            const percentage = Math.round((score / shuffledQuestions.length) * 100);
            const xpEarned = score * 10;
            
            const progress = JSON.parse(localStorage.getItem('t1011-quiz-progress') || '{}');
            if (!progress.chapter8 || percentage > (progress.chapter8.score || 0)) {
                progress.chapter8 = {
                    completed: percentage >= 60,
                    score: percentage,
                    xp: xpEarned,
                    date: new Date().toISOString()
                };
                localStorage.setItem('t1011-quiz-progress', JSON.stringify(progress));
            }

            document.getElementById('quiz-container').classList.add('hidden');
            document.querySelector('.progress-container').classList.add('hidden');
            
            const resultsContainer = document.getElementById('results-container');
            resultsContainer.classList.add('show');
            
            let icon = 'üéâ';
            let title = 'Quiz termin√© !';
            let message = 'Excellent travail !';
            
            if (percentage >= 90) {
                icon = 'üèÜ';
                title = 'Parfait !';
                message = 'Score exceptionnel ! Tu ma√Ætrises parfaitement ce chapitre !';
            } else if (percentage >= 75) {
                icon = 'üéâ';
                title = 'Tr√®s bien !';
                message = 'Excellent score ! Continue comme √ßa !';
            } else if (percentage >= 60) {
                icon = '‚úÖ';
                title = 'Bien jou√© !';
                message = 'Bon score ! R√©vise encore un peu pour viser l\'excellence.';
            } else {
                icon = 'üìö';
                title = 'Chapitre non valid√©';
                message = 'Il faut 60% pour valider. R√©vise le cours et r√©essaye !';
            }
            
            document.getElementById('results-icon').textContent = icon;
            document.getElementById('results-title').textContent = title;
            document.getElementById('results-message').textContent = message;
            document.getElementById('final-score').textContent = percentage + '%';
            document.getElementById('correct-answers').textContent = score;
            document.getElementById('incorrect-answers').textContent = (shuffledQuestions.length - score);
            document.getElementById('xp-earned').textContent = xpEarned;
        }

        function updateProgress() {
            const percentage = Math.round((score / shuffledQuestions.length) * 100);
            const progressPercentage = Math.round(((currentQuestionIndex + 1) / shuffledQuestions.length) * 100);
            
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
            document.getElementById('current-score').textContent = percentage + '%';
            document.getElementById('progress-percentage').textContent = progressPercentage + '%';
            document.getElementById('progress-bar').style.width = progressPercentage + '%';
        }

        function restartQuiz() {
            document.getElementById('results-container').classList.remove('show');
            document.getElementById('quiz-container').classList.remove('hidden');
            document.querySelector('.progress-container').classList.remove('hidden');
            initQuiz();
        }

        document.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>
