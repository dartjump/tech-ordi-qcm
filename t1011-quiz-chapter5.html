<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Chapitre 5 - M√©moire Adressage | T1011</title>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #09090b; --bg-secondary: #18181b; --bg-tertiary: #27272a;
            --bg-card: linear-gradient(145deg, rgba(39, 39, 42, 0.5), rgba(24, 24, 27, 0.8));
            --border: rgba(63, 63, 70, 0.5); --border-hover: rgba(113, 113, 122, 0.5);
            --text-primary: #fafafa; --text-secondary: #a1a1aa; --text-muted: #71717a;
            --accent-1: #3b82f6; --accent-2: #8b5cf6; --success: #22c55e; --danger: #ef4444;
            --gradient-primary: linear-gradient(135deg, #3b82f6, #8b5cf6);
        }
        body { font-family: 'Sora', sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; -webkit-font-smoothing: antialiased; }
        .bg-gradient { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(59, 130, 246, 0.15), transparent), radial-gradient(ellipse 60% 50% at 100% 50%, rgba(139, 92, 246, 0.1), transparent); pointer-events: none; z-index: 0; }
        .noise { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"); opacity: 0.03; pointer-events: none; z-index: 1; }
        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; position: relative; z-index: 2; }
        .header { background: var(--bg-card); backdrop-filter: blur(20px); border: 1px solid var(--border); border-radius: 20px; padding: 24px 32px; margin-bottom: 32px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px; }
        .header-left { display: flex; align-items: center; gap: 16px; }
        .back-btn { display: flex; align-items: center; justify-content: center; width: 44px; height: 44px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; color: var(--text-secondary); text-decoration: none; font-size: 1.3rem; transition: all 0.3s ease; }
        .back-btn:hover { background: var(--bg-tertiary); border-color: var(--border-hover); color: var(--text-primary); transform: translateX(-3px); }
        .header-title h1 { font-size: 1.5rem; font-weight: 700; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header-title p { font-size: 0.85rem; color: var(--text-muted); margin-top: 4px; }
        .header-score { text-align: center; padding: 12px 24px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; }
        .score-value { font-size: 1.8rem; font-weight: 700; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .score-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .progress-container { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 16px; padding: 20px 24px; margin-bottom: 32px; }
        .progress-header { display: flex; justify-content: space-between; margin-bottom: 12px; }
        .progress-text { font-size: 0.85rem; color: var(--text-secondary); font-weight: 600; }
        .progress-bar-bg { height: 10px; background: var(--bg-tertiary); border-radius: 100px; overflow: hidden; }
        .progress-bar { height: 100%; background: var(--gradient-primary); border-radius: 100px; transition: width 0.5s ease; width: 0%; }
        .question-card { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 20px; padding: 32px; margin-bottom: 24px; }
        .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .question-number { font-size: 0.8rem; font-weight: 600; color: var(--accent-1); text-transform: uppercase; letter-spacing: 1px; }
        .question-type { padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 100px; font-size: 0.75rem; font-weight: 500; color: var(--text-muted); }
        .question-text { font-size: 1.1rem; font-weight: 500; color: var(--text-primary); line-height: 1.6; margin-bottom: 24px; }
        .options { display: flex; flex-direction: column; gap: 12px; }
        .option { padding: 16px 20px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.3s ease; font-size: 0.95rem; color: var(--text-secondary); }
        .option:hover { border-color: var(--border-hover); background: var(--bg-tertiary); color: var(--text-primary); }
        .option.selected { border-color: var(--accent-1); background: rgba(59, 130, 246, 0.1); color: var(--text-primary); }
        .option.correct { border-color: var(--success); background: rgba(34, 197, 94, 0.1); color: var(--success); }
        .option.incorrect { border-color: var(--danger); background: rgba(239, 68, 68, 0.1); color: var(--danger); }
        .option.disabled { cursor: not-allowed; opacity: 0.6; }
        .fill-blank-input { padding: 12px 16px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'Sora', sans-serif; font-size: 0.95rem; width: 100%; max-width: 400px; transition: all 0.3s ease; }
        .fill-blank-input:focus { outline: none; border-color: var(--accent-1); background: var(--bg-tertiary); }
        .fill-blank-input.correct { border-color: var(--success); background: rgba(34, 197, 94, 0.1); }
        .fill-blank-input.incorrect { border-color: var(--danger); background: rgba(239, 68, 68, 0.1); }
        .explanation { margin-top: 20px; padding: 16px 20px; background: rgba(59, 130, 246, 0.05); border-left: 3px solid var(--accent-1); border-radius: 8px; display: none; }
        .explanation.show { display: block; }
        .explanation-title { font-size: 0.85rem; font-weight: 600; color: var(--accent-1); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .explanation-text { font-size: 0.9rem; color: var(--text-secondary); line-height: 1.6; }
        .buttons-container { display: flex; gap: 12px; margin-top: 32px; }
        .btn { flex: 1; padding: 14px 24px; border: none; border-radius: 12px; font-family: 'Sora', sans-serif; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: var(--gradient-primary); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 8px 20px -8px rgba(59, 130, 246, 0.5); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-secondary { background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-secondary); }
        .btn-secondary:hover { background: var(--bg-tertiary); border-color: var(--border-hover); color: var(--text-primary); }
        .results-container { background: var(--bg-card); backdrop-filter: blur(10px); border: 1px solid var(--border); border-radius: 20px; padding: 40px; text-align: center; display: none; }
        .results-container.show { display: block; }
        .results-icon { font-size: 4rem; margin-bottom: 20px; }
        .results-title { font-size: 2rem; font-weight: 700; margin-bottom: 12px; background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .results-score { font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 32px; }
        .results-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 16px; margin-bottom: 32px; }
        .result-stat { padding: 16px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; }
        .result-stat-value { font-size: 1.8rem; font-weight: 700; margin-bottom: 4px; }
        .result-stat-value.success { color: var(--success); }
        .result-stat-value.danger { color: var(--danger); }
        .result-stat-value.primary { background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .result-stat-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .hidden { display: none !important; }
        @media (max-width: 768px) {
            .header { flex-direction: column; align-items: flex-start; }
            .header-score { width: 100%; }
            .buttons-container { flex-direction: column; }
            .results-stats { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    <div class="noise"></div>

    <div class="container">
        <div class="header">
            <div class="header-left">
                <a href="t1011-quiz-index.html" class="back-btn">‚Üê</a>
                <div class="header-title">
                    <h1>Chapitre 5 - M√©moire Adressage</h1>
                    <p>Adresse physique, virtuelle, d√©codage</p>
                </div>
            </div>
            <div class="header-score">
                <div class="score-value" id="current-score">0%</div>
                <div class="score-label">Score</div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-header">
                <span class="progress-text">Question <span id="current-question">1</span>/<span id="total-questions">30</span></span>
                <span class="progress-text" id="progress-percentage">0%</span>
            </div>
            <div class="progress-bar-bg">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <div id="quiz-container"></div>

        <div class="results-container" id="results-container">
            <div class="results-icon" id="results-icon">üéâ</div>
            <h2 class="results-title" id="results-title">Quiz termin√© !</h2>
            <p class="results-score" id="results-message">Excellent travail !</p>
            
            <div class="results-stats">
                <div class="result-stat">
                    <div class="result-stat-value primary" id="final-score">0%</div>
                    <div class="result-stat-label">Score Final</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value success" id="correct-answers">0</div>
                    <div class="result-stat-label">Correctes</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value danger" id="incorrect-answers">0</div>
                    <div class="result-stat-label">Incorrectes</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value primary" id="xp-earned">0</div>
                    <div class="result-stat-label">XP Gagn√©</div>
                </div>
            </div>

            <div class="buttons-container">
                <button class="btn btn-secondary" onclick="window.location.href='index.html'">Retour</button>
                <button class="btn btn-primary" onclick="restartQuiz()">Recommencer</button>
            </div>
        </div>
    </div>

    <script>
        const questionsBank = [
            // QCM - Adressage m√©moire
            {
                type: 'qcm',
                question: "Quelle est la diff√©rence entre adresse logique et adresse physique ?",
                options: [
                    "Aucune diff√©rence",
                    "Logique = utilis√©e par CPU, Physique = emplacement r√©el en m√©moire centrale",
                    "Logique = sur disque, Physique = en RAM",
                    "Logique = en cache, Physique = en RAM"
                ],
                correct: 1,
                explanation: "Adresse logique (ou virtuelle) : utilis√©e par les programmes et le CPU. Adresse physique : emplacement r√©el en m√©moire centrale."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce que la m√©moire virtuelle ?",
                options: [
                    "Une m√©moire plus rapide",
                    "L'extension de la m√©moire centrale en utilisant le disque dur",
                    "Une m√©moire cach√©e",
                    "Une m√©moire optique"
                ],
                correct: 1,
                explanation: "La m√©moire virtuelle utilise le disque dur (swap) pour √©tendre la capacit√© de la m√©moire centrale quand celle-ci est insuffisante."
            },
            {
                type: 'qcm',
                question: "Dans la pagination, comment sont organis√©es la m√©moire centrale et le disque ?",
                options: [
                    "En blocs de tailles diff√©rentes",
                    "En pages de m√™me taille",
                    "En segments variables",
                    "En fichiers"
                ],
                correct: 1,
                explanation: "La pagination divise la m√©moire centrale ET le disque (swap) en pages de m√™me taille pour faciliter les √©changes."
            },
            {
                type: 'qcm',
                question: "Que signifie l'algorithme FIFO en gestion de m√©moire ?",
                options: ["First In First Out", "Fast In Fast Out", "Fixed In Fixed Out", "Final In Final Out"],
                correct: 0,
                explanation: "FIFO = First In First Out : la page la plus ancienne (charg√©e depuis le plus longtemps) est remplac√©e en premier."
            },
            {
                type: 'qcm',
                question: "Que signifie l'algorithme LRU en gestion de m√©moire ?",
                options: [
                    "Last Recently Used",
                    "Least Recently Used",
                    "Last Replaced Unit",
                    "Least Replaced Unit"
                ],
                correct: 1,
                explanation: "LRU = Least Recently Used : on remplace la page qui n'a pas √©t√© utilis√©e depuis le plus longtemps."
            },
            {
                type: 'qcm',
                question: "Quelle est la principale diff√©rence entre pagination et segmentation ?",
                options: [
                    "Pagination = tailles fixes, Segmentation = tailles variables",
                    "Pagination = logicielle, Segmentation = mat√©rielle",
                    "Pagination = rapide, Segmentation = lente",
                    "Aucune diff√©rence"
                ],
                correct: 0,
                explanation: "Pagination : pages de taille fixe, m√©canisme mat√©riel transparent. Segmentation : segments de taille variable, d√©coupage logique visible."
            },
            {
                type: 'qcm',
                question: "Dans un syst√®me avec pagination, si une page = 4 Ko (2^12), combien de bits servent au d√©placement dans une adresse de 16 bits ?",
                options: ["4 bits", "8 bits", "12 bits", "16 bits"],
                correct: 2,
                explanation: "Page de 4 Ko = 2^12 octets, donc 12 bits pour le d√©placement (offset). Les 4 bits restants (16-12) donnent le num√©ro de page."
            },
            {
                type: 'qcm',
                question: "Qu'est-ce qu'un 'd√©faut de page' ?",
                options: [
                    "Une erreur de programmation",
                    "Quand la page demand√©e n'est pas en m√©moire centrale",
                    "Une page corrompue",
                    "Une page trop grande"
                ],
                correct: 1,
                explanation: "Un d√©faut de page se produit quand le CPU demande une page qui n'est pas charg√©e en m√©moire centrale (elle est sur le disque)."
            },
            {
                type: 'qcm',
                question: "Quelle est la fonction de la table des pages ?",
                options: [
                    "Stocker les donn√©es du programme",
                    "Traduire les adresses logiques en adresses physiques",
                    "G√©rer l'affichage graphique",
                    "Compresser la m√©moire"
                ],
                correct: 1,
                explanation: "La table des pages contient la correspondance entre num√©ros de pages virtuelles et num√©ros de pages physiques en m√©moire centrale."
            },
            {
                type: 'qcm',
                question: "Dans la segmentation, qu'est-ce qui varie pendant l'ex√©cution du programme ?",
                options: [
                    "Le nombre de segments",
                    "La taille des segments",
                    "L'adresse de base",
                    "Rien ne varie"
                ],
                correct: 1,
                explanation: "Contrairement √† la pagination (taille fixe), la taille des segments peut varier pendant l'ex√©cution du programme."
            },
            {
                type: 'qcm',
                question: "Quels sont les segments typiques d'un programme ?",
                options: [
                    "Code, donn√©es, pile, tas",
                    "Entr√©e, sortie, traitement",
                    "RAM, ROM, Cache",
                    "Processeur, m√©moire, disque"
                ],
                correct: 0,
                explanation: "Un programme segment√© contient : segment de code (instructions), donn√©es (variables globales), pile (param√®tres), tas (allocations dynamiques)."
            },

            // QRM
            {
                type: 'qrm',
                question: "Quelles sont les deux principales techniques de m√©moire virtuelle ? (Plusieurs r√©ponses)",
                options: ["Pagination", "Segmentation", "Compression", "Encryption", "Defragmentation"],
                correct: [0, 1],
                explanation: "Les deux techniques de m√©moire virtuelle sont la pagination (pages fixes) et la segmentation (blocs variables)."
            },
            {
                type: 'qrm',
                question: "Quels sont les avantages de l'algorithme LRU ? (Plusieurs r√©ponses)",
                options: [
                    "Tient compte de la localit√© temporelle",
                    "Choisit la page la moins r√©cemment utilis√©e",
                    "Meilleure performance que FIFO",
                    "Plus simple que FIFO",
                    "Utilise des registres pour m√©moriser l'utilisation"
                ],
                correct: [0, 1, 2, 4],
                explanation: "LRU respecte la localit√©, choisit la page la moins r√©cente, a de meilleures performances que FIFO, mais est plus complexe √† impl√©menter (registres n√©cessaires)."
            },
            {
                type: 'qrm',
                question: "Que contient une table des pages ? (Plusieurs r√©ponses)",
                options: [
                    "Un bit de pr√©sence (page en m√©moire centrale ?)",
                    "Le num√©ro de page physique",
                    "Le d√©placement dans la page",
                    "Les donn√©es du programme",
                    "L'heure du dernier acc√®s"
                ],
                correct: [0, 1],
                explanation: "La table des pages contient : un bit de pr√©sence (1 = en m√©moire centrale) et le num√©ro de page physique correspondant. Le d√©placement vient de l'adresse virtuelle."
            },
            {
                type: 'qrm',
                question: "Quelles affirmations sur la pagination sont correctes ? (Plusieurs r√©ponses)",
                options: [
                    "M√©canisme mat√©riel transparent pour le programmeur",
                    "Pages de taille fixe",
                    "Traduit adresses logiques en adresses physiques",
                    "Le programmeur choisit la taille des pages",
                    "Peut causer des d√©fauts de page"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Pagination : mat√©rielle, transparente, pages fixes, traduction d'adresses, peut avoir des d√©fauts de page. Le programmeur ne choisit PAS la taille des pages."
            },
            {
                type: 'qrm',
                question: "Quelles sont les caract√©ristiques de la segmentation ? (Plusieurs r√©ponses)",
                options: [
                    "D√©coupage logique visible du programmeur",
                    "Segments de tailles variables",
                    "Bas√© sur les fonctions du programme",
                    "Segments de taille fixe",
                    "Utilise base + d√©placement"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Segmentation : d√©coupage logique, tailles variables, bas√© sur les fonctions (code, donn√©es, pile, tas), utilise adressage base+d√©placement."
            },

            // Fill in the blank
            {
                type: 'fill',
                question: "L'adresse _______ est l'emplacement r√©el en m√©moire centrale.",
                answer: ["physique", "Physique"],
                explanation: "L'adresse physique est l'emplacement r√©el v√©hicul√© par le bus d'adresses, contrairement √† l'adresse logique (virtuelle)."
            },
            {
                type: 'fill',
                question: "L'adresse _______ ou virtuelle est utilis√©e par les programmes et le CPU.",
                answer: ["logique", "Logique"],
                explanation: "L'adresse logique (ou virtuelle) est celle utilis√©e par le programme, avant traduction en adresse physique."
            },
            {
                type: 'fill',
                question: "FIFO signifie First In _______ Out.",
                answer: ["First", "first"],
                explanation: "FIFO = First In First Out : la premi√®re page charg√©e est la premi√®re remplac√©e."
            },
            {
                type: 'fill',
                question: "LRU signifie Least _______ Used.",
                answer: ["Recently", "recently"],
                explanation: "LRU = Least Recently Used : on remplace la page utilis√©e le moins r√©cemment."
            },
            {
                type: 'fill',
                question: "La zone du disque dur utilis√©e pour la m√©moire virtuelle s'appelle la _______.",
                answer: ["swap"],
                explanation: "Le swap est la partition du disque dur utilis√©e comme extension de la m√©moire centrale dans la gestion de m√©moire virtuelle."
            },
            {
                type: 'fill',
                question: "Un _______ de page se produit quand la page demand√©e n'est pas en m√©moire centrale.",
                answer: ["d√©faut", "defaut"],
                explanation: "Un d√©faut de page d√©clenche le chargement de la page depuis le disque vers la m√©moire centrale."
            },
            {
                type: 'fill',
                question: "Dans la segmentation, on utilise l'adressage _______ + d√©placement.",
                answer: ["base", "Base"],
                explanation: "La segmentation utilise une adresse de base du segment + un d√©placement (offset) dans le segment."
            },
            {
                type: 'fill',
                question: "La _______ des pages permet de traduire les adresses logiques en adresses physiques.",
                answer: ["table", "Table"],
                explanation: "La table des pages contient la correspondance entre pages virtuelles et pages physiques."
            },
            {
                type: 'fill',
                question: "Dans un programme segment√©, la _______ stocke les param√®tres des fonctions.",
                answer: ["pile", "Pile", "stack"],
                explanation: "Le segment pile (stack) est utilis√© pour le passage de param√®tres et les appels de fonctions."
            }
        ];
            // QCM
            {
                type: 'qcm',
                question: "Quel composant de l'Unit√© de Commande contient l'adresse de la prochaine instruction √† ex√©cuter ?",
                options: ["Registre d'instruction", "D√©codeur", "Compteur ordinal", "S√©quenceur"],
                correct: 2,
                explanation: "Le compteur ordinal (ou Program Counter) contient l'adresse de la prochaine instruction √† ex√©cuter."
            },
            {
                type: 'qcm',
                question: "Que signifie CPU ?",
                options: ["Computer Processing Unit", "Central Processing Unit", "Central Program Unit", "Computer Program Unit"],
                correct: 1,
                explanation: "CPU signifie Central Processing Unit (Unit√© Centrale de Traitement en fran√ßais)."
            },
            {
                type: 'qcm',
                question: "Quel composant interpr√®te l'instruction contenue dans le registre d'instruction ?",
                options: ["Le s√©quenceur", "Le d√©codeur", "Le compteur ordinal", "L'UAL"],
                correct: 1,
                explanation: "Le d√©codeur interpr√®te l'instruction pour d√©terminer quelle op√©ration effectuer et comment aller chercher les op√©randes."
            },
            {
                type: 'qcm',
                question: "Quels sont les deux champs qui composent une instruction ?",
                options: [
                    "Code instruction et code donn√©es",
                    "Code op√©ration et code op√©rande",
                    "Code source et code destination",
                    "Code registre et code m√©moire"
                ],
                correct: 1,
                explanation: "Une instruction est compos√©e de deux champs : le code op√©ration (d√©finit l'action) et le code op√©rande (d√©finit les param√®tres/adresses)."
            },
            {
                type: 'qcm',
                question: "Quel composant g√©n√®re les microcommandes pour piloter les autres entit√©s du ¬µP ?",
                options: ["Le d√©codeur", "Le s√©quenceur", "Le registre d'√©tat", "Le compteur ordinal"],
                correct: 1,
                explanation: "Le s√©quenceur g√©n√®re une s√©quence de microcommandes rythm√©es par l'horloge pour piloter les composants du ¬µP."
            },
            {
                type: 'qcm',
                question: "Que fait l'UAL (ALU) √† la fin d'une op√©ration en cas de d√©bordement ?",
                options: [
                    "Elle arr√™te le processeur",
                    "Elle met le bit OF (OverFlow) du registre d'√©tat √† 1",
                    "Elle efface le r√©sultat",
                    "Elle d√©clenche une interruption"
                ],
                correct: 1,
                explanation: "En cas de d√©bordement (r√©sultat trop grand), l'UAL met le bit OF (OverFlow) du registre d'√©tat √† 1 pour signaler le probl√®me."
            },
            {
                type: 'qcm',
                question: "Comment s'appelle le bus qui v√©hicule les instructions ET les donn√©es entre les composants ?",
                options: ["Bus d'adresses", "Bus de donn√©es", "Bus de commandes", "Bus de contr√¥le"],
                correct: 1,
                explanation: "Le bus de donn√©es (Data Bus) sert au transfert des informations, que ce soient des instructions ou des donn√©es."
            },
            {
                type: 'qcm',
                question: "Quelle est la particularit√© du bus de donn√©es ?",
                options: [
                    "Il est unidirectionnel",
                    "Il est bidirectionnel",
                    "Il ne transporte que des adresses",
                    "Il fonctionne √† sens unique"
                ],
                correct: 1,
                explanation: "Le bus de donn√©es est bidirectionnel car les informations peuvent circuler dans les deux sens : UC ‚Üí m√©moire et m√©moire ‚Üí UC."
            },
            {
                type: 'qcm',
                question: "Avec un bus d'adresse de 16 bits, combien de m√©moire peut-on adresser directement ?",
                options: ["16 Ko", "64 Ko", "256 Ko", "1 Mo"],
                correct: 1,
                explanation: "Avec 16 bits on peut obtenir 2^16 = 65536 combinaisons = 64 Ko de m√©moire adressable."
            },
            {
                type: 'qcm',
                question: "Avec un bus d'adresse de 32 bits, quelle est la taille maximale de m√©moire adressable ?",
                options: ["1 Go", "2 Go", "4 Go", "8 Go"],
                correct: 2,
                explanation: "Un bus d'adresse de 32 bits permet d'adresser 2^32 octets = 4 Go de m√©moire physique."
            },
            {
                type: 'qcm',
                question: "Quel composant du CPU est compos√© de circuits logiques comme des additionneurs et comparateurs ?",
                options: ["L'UC", "L'UAL", "Le d√©codeur", "Le s√©quenceur"],
                correct: 1,
                explanation: "L'UAL (Unit√© Arithm√©tique et Logique) est compos√©e de circuits logiques tels que additionneurs, comparateurs, etc."
            },
            {
                type: 'qcm',
                question: "D'o√π l'UAL re√ßoit-elle ses op√©randes (donn√©es √† manipuler) ?",
                options: [
                    "Du s√©quenceur",
                    "Du bus des donn√©es",
                    "Du registre d'instruction",
                    "Du compteur ordinal"
                ],
                correct: 1,
                explanation: "L'UAL re√ßoit ses op√©randes du bus des donn√©es. Ces donn√©es peuvent provenir de la m√©moire ou de registres."
            },
            {
                type: 'qcm',
                question: "Quel registre m√©morise les √©tats 'particuliers' g√©n√©r√©s par une op√©ration (retenue, d√©bordement, etc.) ?",
                options: ["Registre d'instruction", "Compteur ordinal", "Registre d'√©tat", "S√©quenceur"],
                correct: 2,
                explanation: "Le registre d'√©tat (PSW - Program Status Word) m√©morise les √©tats particuliers via des flags (drapeaux)."
            },
            {
                type: 'qcm',
                question: "Que signifie le flag ZF dans le registre d'√©tat ?",
                options: [
                    "Zero Flag - le r√©sultat est nul",
                    "Zone Flag - zone m√©moire",
                    "Z√©ro Force - forcer √† z√©ro",
                    "Zap Flag - effacer"
                ],
                correct: 0,
                explanation: "ZF (Zero Flag) indique que le r√©sultat de la derni√®re op√©ration est nul (√©gal √† z√©ro)."
            },
            {
                type: 'qcm',
                question: "Dans quel sens circulent les adresses sur le bus d'adresses ?",
                options: [
                    "Bidirectionnel",
                    "Unidirectionnel : UC ‚Üí m√©moire",
                    "Unidirectionnel : m√©moire ‚Üí UC",
                    "Multi-directionnel"
                ],
                correct: 1,
                explanation: "Le bus d'adresses est unidirectionnel : les adresses circulent uniquement dans le sens UC ‚Üí m√©moire."
            },

            // QRM
            {
                type: 'qrm',
                question: "Quels sont les composants de l'Unit√© de Commande (UC) ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Registre d'instruction",
                    "UAL",
                    "D√©codeur",
                    "S√©quenceur",
                    "Registre d'√©tat",
                    "Compteur ordinal"
                ],
                correct: [0, 2, 3, 4, 5],
                explanation: "L'UC comprend : le registre d'instruction, le d√©codeur, le s√©quenceur, le registre d'√©tat et le compteur ordinal. L'UAL fait partie de l'unit√© de calcul, pas de l'UC."
            },
            {
                type: 'qrm',
                question: "Quelles sont les fonctions du CPU ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Acqu√©rir et d√©coder les instructions",
                    "Faire ex√©cuter les op√©rations arithm√©tiques par l'UAL",
                    "G√©rer les adresses du programme via le compteur ordinal",
                    "M√©moriser l'√©tat interne via le registre d'√©tat",
                    "Afficher les r√©sultats √† l'√©cran"
                ],
                correct: [0, 1, 2, 3],
                explanation: "Le CPU acquiert/d√©code les instructions, fait ex√©cuter l'UAL, g√®re les adresses, m√©morise l'√©tat interne et fournit les signaux de commande. L'affichage n'est pas sa fonction."
            },
            {
                type: 'qrm',
                question: "Quels sont les 3 bus fondamentaux du processeur ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Bus de donn√©es",
                    "Bus d'adresses",
                    "Bus de commandes",
                    "Bus de contr√¥le",
                    "Bus m√©moire",
                    "Bus graphique"
                ],
                correct: [0, 1, 2],
                explanation: "Les 3 bus fondamentaux sont : le bus de donn√©es, le bus d'adresses et le bus de commandes (ou contr√¥le)."
            },
            {
                type: 'qrm',
                question: "Quand le compteur ordinal est-il modifi√© ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Au lancement du programme (chargement 1√®re instruction)",
                    "Lors de sauts (boucles, alternatives)",
                    "Il est incr√©ment√© (+1) pour passer √† l'instruction suivante",
                    "Lors d'une division par z√©ro",
                    "Quand la m√©moire est pleine"
                ],
                correct: [0, 1, 2],
                explanation: "Le compteur ordinal est modifi√© : au lancement du programme, lors de sauts, et il est incr√©ment√© (+1) pour les instructions s√©quentielles."
            },
            {
                type: 'qrm',
                question: "Quels flags (indicateurs) peut-on trouver dans le registre d'√©tat ? (Plusieurs r√©ponses possibles)",
                options: [
                    "CF - Carry Flag (retenue)",
                    "ZF - Zero Flag (r√©sultat nul)",
                    "OF - OverFlow (d√©bordement)",
                    "MF - Memory Flag (m√©moire)",
                    "SF - Sign Flag (signe)"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Les flags incluent : CF (Carry), ZF (Zero), OF (OverFlow), SF (Sign). MF n'existe pas dans les registres d'√©tat standards."
            },
            {
                type: 'qrm',
                question: "Que permet le bus de commandes ? (Plusieurs r√©ponses possibles)",
                options: [
                    "Faire circuler les microcommandes du s√©quenceur",
                    "Indiquer ce que le processeur veut faire",
                    "G√©rer les lectures et √©critures",
                    "Transporter des donn√©es",
                    "G√©rer les interruptions"
                ],
                correct: [0, 1, 2, 4],
                explanation: "Le bus de commandes permet la circulation des microcommandes, indique les intentions du processeur (lecture/√©criture), et g√®re les interruptions. Il ne transporte PAS de donn√©es."
            },

            // Fill in the blank
            {
                type: 'fill',
                question: "Le _______ _______ contient l'instruction √† ex√©cuter.",
                answer: ["registre d'instruction", "registre instruction", "RI"],
                explanation: "Le registre d'instruction (RI) contient l'instruction √† ex√©cuter, dont l'adresse se trouve dans le compteur ordinal."
            },
            {
                type: 'fill',
                question: "CPU signifie Central _______ Unit.",
                answer: ["Processing", "processing"],
                explanation: "CPU signifie Central Processing Unit (Unit√© Centrale de Traitement)."
            },
            {
                type: 'fill',
                question: "Le _______ interpr√®te l'instruction pour d√©terminer quelle op√©ration effectuer.",
                answer: ["d√©codeur", "D√©codeur", "decodeur"],
                explanation: "Le d√©codeur interpr√®te le code op√©ration pour savoir quelle op√©ration effectuer et comment chercher les op√©randes."
            },
            {
                type: 'fill',
                question: "Le _______ g√©n√®re les microcommandes rythm√©es par l'horloge.",
                answer: ["s√©quenceur", "S√©quenceur", "sequenceur"],
                explanation: "Le s√©quenceur g√©n√®re une s√©quence de microcommandes chronologiques pour piloter les composants du ¬µP."
            },
            {
                type: 'fill',
                question: "L'Unit√© de Commande et l'Unit√© Arithm√©tique & Logique constituent l'Unit√© _______.",
                answer: ["Centrale", "centrale", "CPU"],
                explanation: "L'UC (Unit√© de Commande) et l'UAL forment ensemble l'Unit√© Centrale (CPU - Central Processing Unit)."
            },
            {
                type: 'fill',
                question: "Le bus de donn√©es est _______ car les informations circulent dans les deux sens.",
                answer: ["bidirectionnel", "Bidirectionnel"],
                explanation: "Le bus de donn√©es est bidirectionnel : les donn√©es peuvent aller de l'UC vers la m√©moire et inversement."
            },
            {
                type: 'fill',
                question: "Le bus d'adresses est _______ : les adresses ne circulent que de l'UC vers la m√©moire.",
                answer: ["unidirectionnel", "Unidirectionnel"],
                explanation: "Le bus d'adresses est unidirectionnel car seule l'UC envoie des adresses vers la m√©moire, jamais l'inverse."
            },
            {
                type: 'fill',
                question: "Le registre d'√©tat est aussi appel√© _______ (Program Status Word).",
                answer: ["PSW", "psw"],
                explanation: "Le registre d'√©tat porte aussi le nom de PSW (Program Status Word) qui m√©morise l'√©tat du processeur via des flags."
            },
            {
                type: 'fill',
                question: "Le compteur ordinal est aussi appel√© _______ (Program Counter).",
                answer: ["PC", "pc"],
                explanation: "Le compteur ordinal est aussi appel√© PC (Program Counter) ou IP (Instruction Pointer)."
            }
        ];

        let currentQuestionIndex = 0;
        let score = 0;
        let answeredQuestions = 0;
        let shuffledQuestions = [];
        let userAnswers = [];

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function initQuiz() {
            shuffledQuestions = shuffleArray(questionsBank);
            currentQuestionIndex = 0;
            score = 0;
            answeredQuestions = 0;
            userAnswers = new Array(shuffledQuestions.length).fill(null);
            document.getElementById('total-questions').textContent = shuffledQuestions.length;
            updateProgress();
            displayQuestion();
        }

        function displayQuestion() {
            const question = shuffledQuestions[currentQuestionIndex];
            const container = document.getElementById('quiz-container');
            let optionsHTML = '';
            
            if (question.type === 'qcm' || question.type === 'qrm') {
                optionsHTML = '<div class="options">';
                question.options.forEach((option, index) => {
                    const isSelected = userAnswers[currentQuestionIndex]?.includes(index);
                    optionsHTML += `<div class="option ${isSelected ? 'selected' : ''}" onclick="selectOption(${index})">${option}</div>`;
                });
                optionsHTML += '</div>';
            } else if (question.type === 'fill') {
                const userAnswer = userAnswers[currentQuestionIndex] || '';
                optionsHTML = `<input type="text" class="fill-blank-input" id="fill-input" placeholder="Entrez votre r√©ponse..." value="${userAnswer}" onkeyup="handleFillInput(event)">`;
            }
            
            const typeLabel = question.type === 'qcm' ? 'QCM' : question.type === 'qrm' ? 'QRM' : 'Texte √† trou';
            
            container.innerHTML = `
                <div class="question-card">
                    <div class="question-header">
                        <div class="question-number">Question ${currentQuestionIndex + 1}</div>
                        <div class="question-type">${typeLabel}</div>
                    </div>
                    <div class="question-text">${question.question}</div>
                    ${optionsHTML}
                    <div class="explanation" id="explanation">
                        <div class="explanation-title">üí° Explication</div>
                        <div class="explanation-text">${question.explanation}</div>
                    </div>
                </div>
                <div class="buttons-container">
                    ${currentQuestionIndex > 0 ? '<button class="btn btn-secondary" onclick="previousQuestion()">Pr√©c√©dent</button>' : ''}
                    ${currentQuestionIndex < shuffledQuestions.length - 1 
                        ? '<button class="btn btn-primary" id="next-btn" onclick="nextQuestion()" disabled>Valider & Suivant</button>'
                        : '<button class="btn btn-primary" id="next-btn" onclick="finishQuiz()" disabled>Valider & Terminer</button>'}
                </div>
            `;

            if (userAnswers[currentQuestionIndex] !== null) {
                document.getElementById('next-btn').disabled = false;
            }
        }

        function selectOption(index) {
            const question = shuffledQuestions[currentQuestionIndex];
            if (question.type === 'qcm') {
                userAnswers[currentQuestionIndex] = [index];
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.toggle('selected', i === index);
                });
            } else if (question.type === 'qrm') {
                if (!userAnswers[currentQuestionIndex]) {
                    userAnswers[currentQuestionIndex] = [];
                }
                const answers = userAnswers[currentQuestionIndex];
                const idx = answers.indexOf(index);
                if (idx > -1) {
                    answers.splice(idx, 1);
                } else {
                    answers.push(index);
                }
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.toggle('selected', answers.includes(i));
                });
            }
            document.getElementById('next-btn').disabled = false;
        }

        function handleFillInput(event) {
            const value = event.target.value.trim();
            userAnswers[currentQuestionIndex] = value;
            document.getElementById('next-btn').disabled = value === '';
        }

        function validateAnswer() {
            const question = shuffledQuestions[currentQuestionIndex];
            const userAnswer = userAnswers[currentQuestionIndex];
            let isCorrect = false;

            if (question.type === 'qcm') {
                isCorrect = userAnswer[0] === question.correct;
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.add('disabled');
                    if (i === question.correct) {
                        opt.classList.add('correct');
                    } else if (userAnswer.includes(i)) {
                        opt.classList.add('incorrect');
                    }
                });
            } else if (question.type === 'qrm') {
                const sortedUser = [...userAnswer].sort();
                const sortedCorrect = [...question.correct].sort();
                isCorrect = JSON.stringify(sortedUser) === JSON.stringify(sortedCorrect);
                document.querySelectorAll('.option').forEach((opt, i) => {
                    opt.classList.add('disabled');
                    if (question.correct.includes(i)) {
                        opt.classList.add('correct');
                    } else if (userAnswer.includes(i)) {
                        opt.classList.add('incorrect');
                    }
                });
            } else if (question.type === 'fill') {
                const normalizedUser = userAnswer.toLowerCase().trim();
                isCorrect = question.answer.some(ans => ans.toLowerCase() === normalizedUser);
                const input = document.getElementById('fill-input');
                input.disabled = true;
                if (isCorrect) {
                    input.classList.add('correct');
                } else {
                    input.classList.add('incorrect');
                }
            }

            if (isCorrect) score++;
            answeredQuestions++;
            document.getElementById('explanation').classList.add('show');
            updateProgress();
        }

        function nextQuestion() {
            if (userAnswers[currentQuestionIndex] === null) return;
            validateAnswer();
            setTimeout(() => {
                currentQuestionIndex++;
                displayQuestion();
                updateProgress();
            }, 1500);
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
                updateProgress();
            }
        }

        function finishQuiz() {
            if (userAnswers[currentQuestionIndex] === null) return;
            validateAnswer();
            setTimeout(() => {
                showResults();
            }, 1500);
        }

        function showResults() {
            const percentage = Math.round((score / shuffledQuestions.length) * 100);
            const xpEarned = score * 10;
            
            const progress = JSON.parse(localStorage.getItem('t1011-quiz-progress') || '{}');
            if (!progress.chapter5 || percentage > (progress.chapter5.score || 0)) {
                progress.chapter5 = {
                    completed: percentage >= 60,
                    score: percentage,
                    xp: xpEarned,
                    date: new Date().toISOString()
                };
                localStorage.setItem('t1011-quiz-progress', JSON.stringify(progress));
            }

            document.getElementById('quiz-container').classList.add('hidden');
            document.querySelector('.progress-container').classList.add('hidden');
            
            const resultsContainer = document.getElementById('results-container');
            resultsContainer.classList.add('show');
            
            let icon = 'üéâ';
            let title = 'Quiz termin√© !';
            let message = 'Excellent travail !';
            
            if (percentage >= 90) {
                icon = 'üèÜ';
                title = 'Parfait !';
                message = 'Score exceptionnel ! Tu ma√Ætrises parfaitement ce chapitre !';
            } else if (percentage >= 75) {
                icon = 'üéâ';
                title = 'Tr√®s bien !';
                message = 'Excellent score ! Continue comme √ßa !';
            } else if (percentage >= 60) {
                icon = '‚úÖ';
                title = 'Bien jou√© !';
                message = 'Bon score ! R√©vise encore un peu pour viser l\'excellence.';
            } else {
                icon = 'üìö';
                title = 'Chapitre non valid√©';
                message = 'Il faut 60% pour valider. R√©vise le cours et r√©essaye !';
            }
            
            document.getElementById('results-icon').textContent = icon;
            document.getElementById('results-title').textContent = title;
            document.getElementById('results-message').textContent = message;
            document.getElementById('final-score').textContent = percentage + '%';
            document.getElementById('correct-answers').textContent = score;
            document.getElementById('incorrect-answers').textContent = (shuffledQuestions.length - score);
            document.getElementById('xp-earned').textContent = xpEarned;
        }

        function updateProgress() {
            const percentage = Math.round((score / shuffledQuestions.length) * 100);
            const progressPercentage = Math.round(((currentQuestionIndex + 1) / shuffledQuestions.length) * 100);
            
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
            document.getElementById('current-score').textContent = percentage + '%';
            document.getElementById('progress-percentage').textContent = progressPercentage + '%';
            document.getElementById('progress-bar').style.width = progressPercentage + '%';
        }

        function restartQuiz() {
            document.getElementById('results-container').classList.remove('show');
            document.getElementById('quiz-container').classList.remove('hidden');
            document.querySelector('.progress-container').classList.remove('hidden');
            initQuiz();
        }

        document.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>
